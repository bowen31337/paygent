"""
Session memory manager for persistent conversation storage.

This module provides memory persistence across agent command executions
using the database-backed AgentMemory model.
"""

import logging
from datetime import datetime
from typing import Any
from uuid import UUID

from sqlalchemy import desc, select
from sqlalchemy.ext.asyncio import AsyncSession

from src.models.agent_sessions import AgentMemory

logger = logging.getLogger(__name__)


class SessionMemoryManager:
    """
    Manages persistent conversation memory for agent sessions.

    Stores and retrieves conversation history from the database,
    enabling agents to maintain context across multiple command executions.
    """

    def __init__(self, db: AsyncSession, session_id: UUID):
        """
        Initialize the session memory manager.

        Args:
            db: Database session for persistence
            session_id: Agent session ID
        """
        self.db = db
        self.session_id = session_id
        logger.info(f"SessionMemoryManager initialized for session {session_id}")

    async def store_conversation(
        self,
        user_message: str,
        agent_response: str,
        message_type: str = "human",
        metadata: dict[str, Any] | None = None
    ) -> UUID:
        """
        Store a conversation turn in the database.

        Args:
            user_message: The user's input message
            agent_response: The agent's response
            message_type: Type of message ("human", "ai", "system")
            metadata: Additional context/metadata

        Returns:
            UUID of the stored memory record
        """
        # Store user message
        user_memory = AgentMemory(
            id=UUID(int=0),  # Will be generated by database
            session_id=self.session_id,
            message_type="human",
            content=user_message,
            timestamp=datetime.utcnow(),
            extra_data=metadata or {}
        )
        self.db.add(user_memory)
        await self.db.flush()  # Generate ID but don't commit yet

        # Store agent response
        agent_memory = AgentMemory(
            id=UUID(int=0),  # Will be generated by database
            session_id=self.session_id,
            message_type="ai",
            content=agent_response,
            timestamp=datetime.utcnow(),
            extra_data=metadata or {}
        )
        self.db.add(agent_memory)
        await self.db.commit()

        logger.info(f"Stored conversation for session {self.session_id}")
        return agent_memory.id

    async def get_conversation_history(
        self,
        limit: int = 10,
        offset: int = 0
    ) -> list[dict[str, Any]]:
        """
        Retrieve conversation history for this session.

        Args:
            limit: Maximum number of turns to retrieve
            offset: Number of turns to skip

        Returns:
            List of conversation turns with message type and content
        """
        query = (
            select(AgentMemory)
            .where(AgentMemory.session_id == self.session_id)
            .order_by(desc(AgentMemory.timestamp))
            .limit(limit)
            .offset(offset)
        )

        result = await self.db.execute(query)
        memories = result.scalars().all()

        # Reverse to get chronological order
        memories = list(reversed(memories))

        return [
            {
                "type": mem.message_type,
                "content": mem.content,
                "timestamp": mem.timestamp.isoformat(),
                "metadata": mem.extra_data or {}
            }
            for mem in memories
        ]

    async def get_recent_context(
        self,
        max_turns: int = 5
    ) -> str:
        """
        Get recent conversation as a formatted context string.

        Args:
            max_turns: Maximum number of turns to include

        Returns:
            Formatted context string for LLM prompts
        """
        history = await self.get_conversation_history(limit=max_turns)

        if not history:
            return ""

        context_parts = []
        for turn in history:
            prefix = "User" if turn["type"] == "human" else "Assistant"
            context_parts.append(f"{prefix}: {turn['content']}")

        return "\n".join(context_parts)

    async def clear_memory(self) -> None:
        """
        Clear all memory for this session.

        Use with caution - this permanently deletes conversation history.
        """
        from sqlalchemy import delete

        await self.db.execute(
            delete(AgentMemory).where(AgentMemory.session_id == self.session_id)
        )
        await self.db.commit()
        logger.info(f"Cleared all memory for session {self.session_id}")

    async def get_memory_count(self) -> int:
        """
        Get the number of memory entries for this session.

        Returns:
            Count of memory records
        """
        query = (
            select(AgentMemory.id)
            .where(AgentMemory.session_id == self.session_id)
        )
        result = await self.db.execute(query)
        return len(result.scalars().all())
